## select 和epoll的区别

selece 的时间复杂度O(n),它仅仅知道了，有io时间发生了，却不知道是哪几个流（可能有一个，多个甚至全部），我们智能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有

## 动态连接和静态连接的区别

1.静态连接特点：在生成可执行文件的时候，把所有需要的函数的二进制代码都包括到可执行文件中去。

**优点**:在程序发布的时候就不需要的依赖库，程序可以独立执行。

**缺点**：程序体积会相对大一些，2如果静态库有更新，所有可执行文件都要重新连接才能上新的静态库

2.动态连接特点：在编译时不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。

**优点**：多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝

**缺点**：由于是运行时加载可能会影响程序的前期执行性能

## static 关键字

一、修饰局部变量

    一般情况下，局部变量放在栈区，其生命周期在执行其包含语句后便结束。static关键字修饰之后，该局部变量存放在静态数据区，生命周期延续到程序结束。

二、修饰全局变量

    static修饰的全局变量的作用域由整个工程变成本文件，使全局变量失去外部链接属性，变为内部链接属性

三、修饰函数

    static修饰函数同全局变量，改变函数作用域由整个工程变为本文件

## struct和union有下列区别（？）

1.在存储多个成员信息时，编译器会自动给struct的所有成员分配存储空间，struct可以存储多个成员信息，而union每个成员会用同一个存储空间，只能存储最后一个成员的信息

2.都是由多个不同的数据类型成员组成，但在任何同一时刻，union只存放了一个先被选中的成员，而结构体的所有陈公园都存在

3.对于union的不同成员幅值，将会对其他成员重写，原来成员的值就不存在了，而对于struct的不同成员赋值时互不影响的。

## 三目运算符

    三目运算符由两大部分组成，”？“前面时判断条件，如果前面的运算结果时1，即前面的条件成立，执行”：“前面，”？“后面的执行结果，反之执行”：“后面的表达式

c=a>b?a:b;

## 信号量和互斥量的区别和应用场景

1 互斥量用于线程的互斥，信号量用于线程的同步，这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别

2互斥量的值只能是0/1，信号量的值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题给i。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问。

3.互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

## 什么是多态，有什么用。

c++多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。

**目的**：接口重用。封装可以使得代码模块快画，继承可以拓展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。

**用法**：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。

## c语言存储区划分

在c语言中，存储区可以分成代码区，全局区，常量区，栈，堆；

![](D:\jobthing\embedpicture\cdepart.jpg)

全局区：主要存储全局变量和static变量

常量区：存放常量的地方

堆：用户申请的内存区，用编译器提供的函数new或malloc申请。**要注意内存泄漏问题**

栈：系统自动给局部变量分配的内存区。

extern关键词：extern修饰全局变量glovar时，表明glovar可以被其他模块的函数使用；

                            extern修饰函数是，表明函数可以被其他模块的函数调用；

static关键词：static

## 为什么要引入指针

指针本身就是内存地址的抽象化，内存地址本身是计算机不可避免的，这也是有的人强调“指针天然存在”、“指针就是内存地址”的原因



## int 和unsigned int的区别

unsigned int 是[无符号整型](https://so.csdn.net/so/search?q=%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B&spm=1001.2101.3001.7020)，要求定义的整数一定是正整数。

## 关键字volatile有什么含义，并且给出三个不同的例子

    volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或者读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。

     如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

## define 和typedef的区别

语法格式不同：typedef定义是语句，句尾加上分号；而define不是语句，不能再句尾加分号。

用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性；而define主要用来定义常量，以及书写复杂的使用频繁的宏

执行时间不同：typedef是编译过程的一部分，有类似检查的功能；define是宏定义，是预编译部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

作用域不同：typedef有作用域限定，define不受作用域的约束，只要在define命令后的引用都是正确的。

## 访问固定的内存位置

要求设置一个绝对地址为0x67a9的整形变量的值为0xaa66.

```c
//答主自己的答案
int *addr=(int*)0x67a9;
*addr=0xaa66;
```

```c
int* ptr;
ptr=(int*)0x67a9;
*ptr=0xaa55;
```

## memcpy函数的实现

memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所致的内存地址的起始位置中

```c
void* memcpy(void *dest,const void *src,size_t count){
    char *d;
    const char *s;

    if((dest>(src+size))||(dest<src))
    {
        d=dest;
        s=src;
        while(count--)
            *d++=*s++;
    }
    else/*overlap*/
    {
        d=(char *)(dest+count-1);//offset of pointer is from 0
        s=(char *)(src+count-1);
        while(count--)
            *d--=*s--;
    }
return dest;
}
```

## 没定义的变量使用了，报错的原因是什么

定义了之后才会分配内存空间，不同类型的变量内存空间不同，如果未定义的话，没有被分配内存空间，所以没法使用

## inline函数
