## select 和epoll的区别

selece 的时间复杂度O(n),它仅仅知道了，有io时间发生了，却不知道是哪几个流（可能有一个，多个甚至全部），我们智能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有

## 动态连接和静态连接的区别

1.静态连接特点：在生成可执行文件的时候，把所有需要的函数的二进制代码都包括到可执行文件中去。

**优点**:在程序发布的时候就不需要的依赖库，程序可以独立执行。

**缺点**：程序体积会相对大一些，2如果静态库有更新，所有可执行文件都要重新连接才能上新的静态库

2.动态连接特点：在编译时不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。

**优点**：多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝

**缺点**：由于是运行时加载可能会影响程序的前期执行性能

## static 关键字

一、修饰局部变量

    一般情况下，局部变量放在栈区，其生命周期在执行其包含语句后便结束。static关键字修饰之后，该局部变量存放在静态数据区，生命周期延续到程序结束。

二、修饰全局变量

    static修饰的全局变量的作用域由整个工程变成本文件，使全局变量失去外部链接属性，变为内部链接属性

三、修饰函数

    static修饰函数同全局变量，改变函数作用域由整个工程变为本文件

## struct和union有下列区别（？）

1.在存储多个成员信息时，编译器会自动给struct的所有成员分配存储空间，struct可以存储多个成员信息，而union每个成员会用同一个存储空间，只能存储最后一个成员的信息

2.都是由多个不同的数据类型成员组成，但在任何同一时刻，union只存放了一个先被选中的成员，而结构体的所有陈公园都存在

3.对于union的不同成员幅值，将会对其他成员重写，原来成员的值就不存在了，而对于struct的不同成员赋值时互不影响的。

## 三目运算符

    三目运算符由两大部分组成，”？“前面时判断条件，如果前面的运算结果时1，即前面的条件成立，执行”：“前面，”？“后面的执行结果，反之执行”：“后面的表达式

c=a>b?a:b;

## 信号量和互斥量的区别和应用场景

1 互斥量用于线程的互斥，信号量用于线程的同步，这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别

2互斥量的值只能是0/1，信号量的值可以为非负整数。也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题给i。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问。

3.互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

## 什么是多态，有什么用。

c++多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的；动态多态是通过虚函数实现的。

**目的**：接口重用。封装可以使得代码模块快画，继承可以拓展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。

**用法**：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。

## c语言存储区划分

在c语言中，存储区可以分成代码区，全局区，常量区，栈，堆；

![](D:\jobthing\embedpicture\cdepart.jpg)

全局区：主要存储全局变量和static变量

常量区：存放常量的地方

堆：用户申请的内存区，用编译器提供的函数new或malloc申请。**要注意内存泄漏问题**

栈：系统自动给局部变量分配的内存区。

extern关键词：extern修饰全局变量glovar时，表明glovar可以被其他模块的函数使用；

                            extern修饰函数是，表明函数可以被其他模块的函数调用；

static关键词：static

## 为什么要引入指针

指针本身就是内存地址的抽象化，内存地址本身是计算机不可避免的，这也是有的人强调“指针天然存在”、“指针就是内存地址”的原因

## int 和unsigned int的区别

unsigned int 是[无符号整型](https://so.csdn.net/so/search?q=%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B&spm=1001.2101.3001.7020)，要求定义的整数一定是正整数。

## 关键字volatile有什么含义，并且给出三个不同的例子

    volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或者读取这个变量的时候，告诉编译器对该变量不做优化，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。

     如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。

## define 和typedef的区别

语法格式不同：typedef定义是语句，句尾加上分号；而define不是语句，不能再句尾加分号。

用法不同：typedef用来定义一种数据类型的别名，增强程序的可读性；而define主要用来定义常量，以及书写复杂的使用频繁的宏

执行时间不同：typedef是编译过程的一部分，有类似检查的功能；define是宏定义，是预编译部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

作用域不同：typedef有作用域限定，define不受作用域的约束，只要在define命令后的引用都是正确的。

## 访问固定的内存位置

要求设置一个绝对地址为0x67a9的整形变量的值为0xaa66.

```c
//答主自己的答案
int *addr=(int*)0x67a9;
*addr=0xaa66;
```

```c
int* ptr;
ptr=(int*)0x67a9;
*ptr=0xaa55;
```

## memcpy函数的实现

memcpy指的是c和c++使用的内存拷贝函数，memcpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所致的内存地址的起始位置中

```c
void* memcpy(void *dest,const void *src,size_t count){
    char *d;
    const char *s;

    if((dest>(src+size))||(dest<src))
    {
        d=dest;
        s=src;
        while(count--)
            *d++=*s++;
    }
    else/*overlap*/
    {
        d=(char *)(dest+count-1);//offset of pointer is from 0
        s=(char *)(src+count-1);
        while(count--)
            *d--=*s--;
    }
return dest;
}
```

## 没定义的变量使用了，报错的原因是什么

定义了之后才会分配内存空间，不同类型的变量内存空间不同，如果未定义的话，没有被分配内存空间，所以没法使用

## inline函数

在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。

inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数

## c语言和c++的区别

 函数上：c++支持重载，c不支持，主要原因是c++函数的名字修饰和c不同，c++在函数名字修饰时，会把参数放在后面，如int a（int b,char c）会被修饰成_a_int_char,而c只会修饰成_a，，所以c++中支持不同参数调用不同的函数，即支持函数从在；c++还有虚函数的概念，用来实现多态。

struct上：c的struct像是一个数据结构的集合，而c++的struct不仅包含成员函数，还有成员变量，同时还增加了访问权限的概念

## 重写重载和隐藏的定义

**重载**：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏

**重写**：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类被重写的函数必须有virtual修饰

## virtual函数

virtual时c++中在类base中加了virtual关键字的函数就是虚拟函数。

基类的函数调用如果有virtual则根据多态性调用派生类的。如果没有virtual则时正常的静态函数调用，还是调用基类的。

## const和define的区别

const定义的常量是变量也带类型，占用数据段空间。

define定义的只是常熟，不带类型，占用代码段空间

define是在编译的预处理阶段起作用，而const是在编译运行的时候起作用

## extern c的作用

显式的说明某些变量或者函数的存储空间是在程序的其他地方分配的，在文件中其他位置或者文件中寻找a这个变量

1. 一个c文件需要调用另一个c文件中的变量或者函数而不能从.h文件中调用变量

2. 引用函数：如果调用其他c文件中的韩素华，在文件中的函数声明前面加extern就行，不加extern而直接声明函数也可以，因为声明全局函数默认前面有extern

如果不想让其他.c文件引用本文件中的变量，加上static即可

## 多态

多态就是一个接口有多种形态，c++中有静态多态，动态多态，静态多态是函数重载和模板

多态一半指动态多态，c++是通过虚函数实现，具体的就是，只要含有虚函数的类就会为该类生成一个全局唯一虚函数表，虚函数表中记录类中虚函数的入口地址，同时会在每个实例内存的开始生成一个虚函数表指针，指向虚函数表。

而当一个子类继承一个有虚函数的父类厚，同时也会继承父类的虚函数表，如果子类重写一个虚函数，就会把虚函数表中该虚函数的地址改成重写后的版本。

这样一个父类指针指向一个子类对象，想要调用某虚函数时，通过对象内存地址找到的是子类虚函数表，就可以调用子类的版本。这九实现了多态，即一个父类指针指向不同的对象，调用相同的函数，表现出不同的形态

## 说一说const的用法

const用于定义常量：const定义的常量编译器可以对其进行数据静态类型安全检查。

const修饰函数形式参数：当输入参数为永辉自定义类型和抽象数据类型时，将“值传递”改为“const&传递”可以提高效率

const修饰函数的返回值：如果给“指针传递”的函数返回值加上const，则返回值不能被直接修改，且该返回值智能被赋值给const修饰的同类型指针

## 栈的内存在哪些地方？哪些地方会用到栈

栈是函数定义了结构体或变量，当函数返回的时候，这个结构体的空间就被释放掉了。栈是一块内存，我们需要的是东西能让被调用函数执行完以后取指令的位置再退回到调用位置，我们需要找到一块地方暂存当前cpu指令执行到的位置，这块地方就是栈

## 在函数立定义一个很大的数组，应该直接定义还是用malloc

应该用malloc如果需要开一个很大的数组，比如10000000，如果在函数内部定义的话编译的时候总是出现“[Error] size of array ‘flag’ is too large ”的错误

## 栈和队列

出入方式不同：栈先进后出，队列先进先出

操作位置不同：因为栈先进后出，它在一端进行操作；而队列是先进先出，在两端进行操作。

## 头文件重复包含

#ifndef _HEADername_h

#define _HEADERNAME_H

//头文件内容

#endif

## 父函数不能调用子函数独有的虚函数

父类和子类都有“相同”原型的虚函数，才能根据父类指针指向的对象类型不同，在调用父类或子类的虚函数时表现出多态。父类有虚函数而子类没有，或反之都不能表现出多态行为。当用父类指针调用一个函数时，不管该函数是不是虚函数，它一定要在本质真所属的父类存在否则编译因找不到函数肯定会报错，所以子类独有虚函数用父类指针调用，编译程序肯定会报错

## 虚函数表？？

## 空类的sizeof大小

在类中，如果什么都没有，则类占用一个字节，一旦类中有其他的占用空间成员，则这一个字节就不在计算之内。一个只有int的类占用4字节而不是5字节

如果只有成员函数，则还是只占用1个字节，因为类函数不占用空间

虚函数因为存在一个虚函数表，需要4个字节，数据成员对象如果为指针则4字节。

## 深拷贝和浅拷贝

浅拷贝是指源对象和拷贝对象公用一份实体，仅仅时引用的变量不同（名臣不同）。堆七中任何一个对象的改动都会影响另外一个对象、

深拷贝是指源对象和拷贝对象互相独立，七中任何一个对象的改动都不会对另外一个对象造成影响。

## 可重入函数

可重入函数是指能够被多个线程“同时”调用的函数，并且能保证函数结果正确不必担心数据错误的函数

不可重入函数是指不能运行在多任务环境下，除非能保证互斥的函数

[C++可重入函数和不可重入函数_Sunrise的博客的博客-CSDN博客](https://blog.csdn.net/weixin_41969690/article/details/108006834)

## c和c++的优缺点

c++支持函数重载，还有c语言没有的类，c语言中只有struct；扩展性好，复用性好

c语言可以直接访问硬件，运行效率高，但是扩展性差

## c语言的内存管理

**四个区**：代码区，静态区，栈区，堆区

代码区：程序被操作系统加载到内存的时候，所有的可执行代码都加载到代码区，这块内存在程序运行期间是不变的

静态区：存放所有的全局变量和静态变量

栈：所有的自动变量函数形参都在，有编译器自动完成，

堆：堆是一个大容器，容量远大于栈，需要自己申请和释放内存，malloc和free成对使用

## c语言的线程池

线程池允许一个线程可以多次复用，且每次复用的线程内部的消息处理可以不相同，将创建与销毁的开销省区而不必来一个请求开一个线程

## 指针与引用的区别

1. 引用必须被初始化，指针不必

2. 引用初始化以后不能被改变，指针可以改变所指的对象

3. 不存在指向空值的引用，但是存在指向空值的指针。

## 指针的优缺点

1. 提高程序的编译效率和执行速度，使程序更加简洁

2. 利用指针可以实现动态内存分配

3. 可以直接操作内存地址，从而完成汇编之类的操作

缺点：如果不能正确理解和灵活运用，容易隐含各式各样的错误，可读性也变差

## 常用的位操作

```c
&            // 按位与 
|            //按位或
^            //按位异或
<<            //按位左移
>>            //按位右移
```

## 未初始化的静态变量的值是多少

 全局变量，静态变量初始值位0

局部变量，自动变量初始值随机分配

## 中断要传入什么参数？中断可以有返回值么？

中断不能有返回值

中断处理函数不能有返回值和形参，因为中断处理函数是由硬件（或触发器）调用的，没有程序向其传递参数也没有程序接收其返回值，其参数通过全局变量传递。

## 5.若栈的长度较小有什么注意事项

每个函数都要分配栈，函数执行完就要废弃，生存期短。不能用作返回值，需要返回的数据必须放到堆里。栈智能放一些临时数据，且栈不能动态申请内存，

公共数据、动态数据都放堆里，堆自然就大了。

## malloc使用要注意什么

1. 要注意使用malloc函数分配内存后要判断内存是否分配成功，不成功要做相应处理

2. 内存使用结束后将内存free掉

3. 释放内存后的指针指向nullptr

## 除了局部变量和全局变量 还有什么变量 分别有什么作用

static静态局部变量和非静态局部变量

静态局部变量和普通局部变量不同，静态局部变量所在的函数调用多次时，只有第一次才会经历变量初始化，以后调用不在定义和初始化。

静态局部变量在第一次函数被调用时创造并初始化，但在函数退出时不会死亡，等待被下一个函数继续调用



## 2、c编译到执行的4个阶段

预处理，编译，汇编，链接

## 一个无符号类型的数，将他的二进制最后一位由1改成0

```c
  //把某个证书中的二进制第n位设为1：Num|=(Num<<N)
  //第n位设为0，Num&=~(Num<<N)
```

## 怎么使用指针p表示二维数组的第三个元素

p=*(a)+2,第三个元素时012

## 指针占几个字节

一个指针在32位的计算机上，占4个字节；  
一个指针在64位的计算机上，占8个字节。

**64位能表示的数值个数是多少？很简单，2^64个，数值范围就是从0到2^64 - 1，这也是如今64位CPU的寻址范围，用16进制表示就是：0---FFFF FFFF FFFF FFFF(F是数值15，二进制就是1111,刚好是四位，所以2个16进制位就是一个字节)，那么重点就从这儿开始了，如果想让一个指针变量存储的数值能表示完所有的寻址范围(也就是所有的地址值)，那么毋庸置疑，他的存储空间必须是大于等于64bit，也就是8个字节，少一个bit，都不能完整的表示完所有的寻址范围，刚好，8个字节刚好能不多一位不少一位的表示完所有的寻址范围，因此就是8个字节。同理的32位下就是4个字节**

## 调用另一个头文件函数怎么弄

include之后还要ifndef def endif

## 用宏求两个数中的较大值

```c
#define MAX(x,y) x>y?x:y
```

## 结构体和类的区别

1. 结构体时能够封装c语言中已经存在的数据类型和自定义的数据类型，但是不能含有函数。

2. c++中的结构体相当于一个特殊的类

3. c语言定义结构体变量要加上struct 而c++不需要加

## 没定义的时候结构体默认是什么类默认是什么？

## 枚举和共同体

枚举：把可能的取值一一列举。

enum tag{

    xx,

    yy

};

如果没赋值这些按照%d的数字显示就是0123

如果赋值了就按照赋值之后的依次增加，赋值前的从零开始

## malloc和new的区别

1. new是操作符，malloc是函数

2. new使用时先分配内存，再调用构造函数，释放时使用析构函数

3. new智能分配实例所占类型的整数倍，malloc可以随意分配

4. new失败返回异常，malloc返回NULL

## c语言内存分配方式

1. 静态区分配：编译时分配好，主要储存全局变量，static变量等

2. 栈分配：执行函数时，函数内部的局部变量，函数结束时，这些存储党员自动被释放

3. 堆分配：也叫动态分配，通过malloc以及new来分配

## 3、struct 与 class的区别

1、class可以继承，类，接口，struct只能继承接口
2、class有默认的无参构造函数，struct没有，而且struct没有析构函数
3、class有继承级别，protected等等
4、class用垃圾回收机制保证内存的回收，struct使用完之后自动接触内存分配。

## 21、如何防止Double Free

先判断一波
if(p)
{
   free(p);
}

## 23、fopen和open的区别

fopen为C语言标准库函数，open是Linux系统函数，所以open是底层函数，fopen为应用函数，所以fopen只能打开常规文件，但是open可以打开描述符。

## 4.宏函数定义写一个交换数据

```c
#define SWAP(a,b,type) do{type temp=a;a=b;b=temp;}while(0)
```

## c语言的程序结构

顺序，选择，循环
